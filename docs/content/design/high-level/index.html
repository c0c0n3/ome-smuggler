<!DOCTYPE html>
<!--
 * Adapted from: https://github.com/c0c0n3/c0c0n3.github.io/blob/master/index.html
 * (commit: https://github.com/c0c0n3/c0c0n3.github.io/commit/7bc099eb27309ee19b9bff5b8fcd0fc2985f3623) 
-->
<html lang="en">
<head>
  <title>High-level View</title>
  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" type="text/css" href="http://necolas.github.io/normalize.css/latest/normalize.css" />
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Alegreya" />
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Kaushan+Script" />
  <link rel="stylesheet" type="text/css" href="../../../css/style.css" />
  <link rel="stylesheet" type="text/css" href="../../../css/zenburn-highlighter.css" />
  
</head>

<body>

<header>
  <section id="header">
    <h1 id="title">High-level View</h1>

    <p id="slogan">as seen from the moon</p>

  </section>
</header>

<main>
  <section id="content">
  <p class="intro">
The basic idea: a Web-based work queue to run tasks on behalf of OMERO clients.
</p>
<p>A task is queued, then run and as it runs a URL is available from which to get status updates. If the task fails, it may be retried. On completion, an email report is sent to the interested parties. This is Smuggler’s life purpose—at least for now. And for now, the only task Smuggler knows how to run is an OMERO import. If you haven’t done it yet, now it’d be a good time to take Smuggler for a spin as explained <a href="../../../content/examples/whirlwind-tour.html" title="Whirlwind Tour">here</a> so you have a good idea of how Smuggler’s REST API works before we look at what happens under the bonnet.</p>
<h2 id="conceptual-overview">Conceptual Overview</h2>
<p>Smuggler is a server that makes available two main service points: the one to run an OMERO import and the other to monitor and manage failed imports. In both instances, service access is over HTTP and client-server interaction patterns are those of REST. Smuggler is a <a href="http://projects.spring.io/spring-boot/" title="Spring Boot Home">Spring Boot</a> app with an embedded <a href="http://undertow.io/" title="Undertow Home">Undertow</a> Web server engine that propels external interaction with HTTP clients. Internally, HTTP requests and responses are managed by the <a href="https://spring.io/" title="Spring Home">Spring</a> MVC framework that runs the request handlers in Smuggler’s Web front-end component, named <em>REST Controllers</em>. These handlers turn Web requests into calls to an internal service API and massage the results back into Web responses. This internal service API is provided by the Smuggler component named <em>services</em>; this component is where the actual app logic sits.</p>
<p>The <em>services</em> component splits work into tasks and sends them as messages on an asynchronous messaging channel; the channel then delivers these messages (asynchronously) back to the <em>services</em> task handlers that carry out the work; in turn, a task handler may put more messages on the channel to ask another handler to do some other work. This mechanism is akin to continuations in functional programming, where you can save your task’s state at any point, then get back to it later to do some more work, and so on until you’re done with the task.</p>
<p>The asynchronous messaging channel is a service provided by yet another of Smuggler’s components: <em>messaging</em>. This channel abstraction is loosely (very loosely!) based on Communicating Sequential Processes and is implemented using message queues, courtesy of <a href="http://hornetq.jboss.org/" title="HornetQ Home">HornetQ</a> and its neat Core API. Though the implementation is transparent to the <em>services</em> component, using message-oriented middleware brings a lot of added value into Smuggler as a whole. For starters, queues are persistent and so, after a crash, Smuggler can pick up a task from where he left it when he was so rudely interrupted. Also a queue can act as an effective back-pressure mechanism when OMERO is overloaded; work can be split across queues on different machines to cope with increased workloads; and so on. In short, we can use message queues as a foundation to build a <a href="http://www.reactivemanifesto.org/" title="Reactive Manifesto">reactive system</a>.</p>
<p>[TODO: a para on tech stack][Late night silly thought: Java, having become the bastion of [abject-orientation] (http://typicalprogrammer.com/abject-oriented/), is now also poised to be the sanctuary of dysfunctional programming. ]</p>
<p>Why not condense this lengthy explanation of what Smuggler looks like under the hood in a pretty diagram?</p>

<figure id="components">
  <div><a href="components.svg">view full screen</a></div>
  <object type="image/svg+xml" data="components.svg">
  your browser doesn't support embedded SVG; 
  click on the link above to see the image.
  </object>
  <figcaption>
    Wiring of Smuggler’s components and third-party software.<br /> UML component diagram.
  </figcaption>
</figure>

<p>The note at the bottom of the diagram tells you how the conceptual components map to Java packages. You can find a lot more about source code breakdown and dependencies in the next section. But before we dive deep into the source, a word of caution: the tech sauce is quite heavy to digest so it may be too much to gulp down in just one go if you’re not already pretty familiar with all the various techs we use. (It proved definitely too much for me, I tell you my tummy wasn’t a happy camper for days afterwards!) In that case, it’s probably best to take it slowly and skill up a bit before hand (as I did myself!), especially on Java 8 (dys-)functional programming and Streams API.</p>
<div class="side-note">
<h6 id="springdoh">Spring…D’oh!</h6>
<p>Before starting developing Smuggler, we built a prototype app to learn about and experiment with the various (many!) bits and pieces that make up our current technology stack. Aptly named “Spring…D’oh”, this initial prototype has basically no app logic but pretty much the same architecture and exactly the same technology stack as Smuggler; we actually used its source base as a blueprint for Smuggler’s. If you’re not familiar with Java 8, Spring, Messaging, and all the other techs in Smuggler, “Spring…D’oh” may be a good starting point to get to grips with all this madness as it should be easier to see how the pieces of the puzzle all fall into place. At least it helped me… You can find the <a href="https://github.com/c0c0n3/spring-doh" title="Spring D'oh Project on GitHub">project on GitHub</a>.</p>
</div>
<h2 id="codebase-essentials">Codebase Essentials</h2>
<p>Time to start digging into the source. Besides bringing your bucket and spade, it may help at this point to keep your editor handy so to be able to move back and forth between the code and the narrative below.</p>
<p>The source base is split into two root packages: <code>ome.smuggler</code>, containing the app itself, and <code>util</code>, a general-purpose library whose code is totally independent of Smuggler and reusable across projects. In fact, <code>util</code> is part of the dowry we got when we forked from <a href="#springdoh">Spring D’oh</a>. Since then we added a few more <code>util</code> classes but we can potentially ditch the whole lot if there’s a better alternative. In any case, if you realise some of the code you’re writing for Smuggler can be generalised to make it reusable in other projects, well, now you know where to put it :-)</p>
<p>With that out of the way, let’s have a closer look at what’s in <code>ome.smuggler</code>. For starters, this is how Smuggler’s components map to actual Java code:</p>
<ul>
<li>the <em>REST controllers</em> are in the <code>web</code> package;</li>
<li>the <em>services</em> are in <code>core.service</code>;</li>
<li>the <em>messaging</em> functionality is split between <code>q</code> and <code>core.mgs</code>;</li>
<li>whereas we keep all <em>config</em> in, well you guessed it, <code>config</code>.</li>
</ul>
<p>A few more words about messaging. The split mentioned above is between the abstract definition of the messaging functionality we need—the content of <code>core.msg</code>—and the actual implementation in terms of a specific message oriented middleware, HornetQ at the moment, that sits in <code>q</code>. The idea is that Smuggler should play the messaging game only by the rules (interfaces) defined in <code>core.msg</code> without caring about the actual implementation in <code>q</code>. Accordingly, the only code that depends on <code>q</code> is that in <code>config</code> as it needs to tie the interfaces in <code>core.msg</code> to the actual implementations in <code>q</code> and make them available through Spring. To keep our sanity, we decided to do away with both JMS and Spring’s own flavour of it: the code in <code>q</code> piggybacks directly on the HornetQ Core API to implement the various interfaces defined in <code>core.msg</code>. Besides these interfaces, <code>core.msg</code> is home to classes that carry out generic messaging tasks that only depend on the <code>core.msg</code> interfaces.</p>
<p>Think it’s time we started visualising all these packages and dependencies so we can actually <em>see</em> what was the thinking behind the code structure breakdown. Here goes.</p>

<figure id="package-dependencies">
  <div><a href="package-dependencies.svg">view full screen</a></div>
  <object type="image/svg+xml" data="package-dependencies.svg">
  your browser doesn't support embedded SVG; 
  click on the link above to see the image.
  </object>
  <figcaption>
    Top level Java packages and their dependencies.<br /> UML package diagram.
  </figcaption>
</figure>

<p>As noted in the diagram, the bulk of the functionality sits in <code>core</code> and is not meant to have any dependencies on third-party libraries. This way we can change the underlying frameworks we use without having to rewrite the whole app from scratch. For example, using a Web server other than Undertow requires just a few configuration tweaks—picture rubbing off Undertow from the diagram and follow the arrows to see what would be affected. Ditching HornetQ would take slightly more work as some of the code in <code>q</code> would need to change. Moving away from Spring? A bit more involved, but still doable.</p>
<p>There are a few more packages shown in the diagram that we haven’t touched on yet, but looking at them is not essential to get the hang of the code base. Anyway, let’s just mention what they’re there for. In <code>core</code>, you’ll find <code>types</code>, which is where we keep the shared data types we use to shuttle data across app components; <code>convert</code> and <code>io</code> contain, respectively, some util classes to deal with JSON serialisation and files. Finally, if you’re wondering how the Web app starts or how we generate config files, then you should look at the launchers in <code>run</code>.</p>
  </section>
</main>  

<footer>
  <section id="footer">
    <p>generated with <a href="https://jaspervdj.be/hakyll/">Hakyll</a></p>
    <p><a href="https://github.com/c0c0n3/ome-smuggler/tree/gh-pages">source code</a></p>
    <!-- TODO fonts; legal? -->
  </section>
</footer>
  
</body>
</html>
