<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ClassPath.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Smuggler All Tests (Mar 29, 2016 9:20:39 AM)</a> &gt; <a href="../../index.html" class="el_group">ome-smuggler</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">util.runtime.jvm</a> &gt; <span class="el_source">ClassPath.java</span></div><h1>ClassPath.java</h1><pre class="source lang-java linenums">package util.runtime.jvm;

import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;
import static util.string.Strings.isNullOrEmpty;

import java.io.File;
import java.nio.file.Path;
import java.util.LinkedHashSet;
import java.util.stream.Stream;


/**
 * Represents a JVM class path.
 */
public class ClassPath {
    
    /**
     * The string to use for separating class path entries.
     */
<span class="fc" id="L21">    public static final String Separator = File.pathSeparator;</span>
    
    
    private LinkedHashSet&lt;Path&gt; entries;
    
    /**
     * Creates a new {@link #isEmpty() empty} class path.
     */
<span class="fc" id="L29">    public ClassPath() {</span>
<span class="fc" id="L30">        entries = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L31">    }</span>
    
    /**
     * Does this class path have any path entries?
     * @return {@code true} for yes, {@code false} for no.
     */
    public boolean isEmpty() {
<span class="fc" id="L38">        return entries.isEmpty();</span>
    }
    
    /**
     * Appends the given entries to this class path.
     * This method will preserve the order in which entries are given as well
     * as the order in which they were added; e.g. {@code add(x).add(y, z)} 
     * will yield a class path of {@code x:y:z}.
     * If an entry was already in the class path, this method will not add it
     * again. This is consistent with the way the JVM searches the class path, 
     * as a class path of {@code x:y:x} is equivalent to {@code x:y}.
     * Also, each entry will be normalized before appending; if it turns out
     * to be the empty path, then it will not be appended.
     * @param xs the entries to add; they will be added in the given order from
     * left to right.
     * @return itself to facilitate fluent API style.
     * @throws NullPointerException if the argument is {@code null} or any of 
     * its elements are {@code null}.
     * @see #toStream()
     * @see #toString()
     */
    public ClassPath add(Path...cpEntries) {
<span class="fc" id="L60">        return add(Stream.of(cpEntries));</span>
    }
    
    /**
     * Convenience method, same as {@link #add(Path...)}.
     * @param cpEntries the entries to add; the stream must be ordered.
     * @return itself to facilitate fluent API style.
     * @throws NullPointerException if the argument is {@code null} or any of 
     * its elements are {@code null}.
     */
    public ClassPath add(Stream&lt;Path&gt; cpEntries) {
<span class="fc" id="L71">        requireNonNull(cpEntries, &quot;cpEntries&quot;);</span>
        
<span class="fc" id="L73">        cpEntries.map(p -&gt; requireNonNull(p))</span>
<span class="fc" id="L74">                 .map(Path::normalize)</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">                 .filter(p -&gt; !isNullOrEmpty(p.toString()))</span>
<span class="fc" id="L76">                 .forEachOrdered(entries::add);</span>
        
<span class="fc" id="L78">        return this;</span>
    }
    
    /**
     * Appends all the entries in the given class path to this class path.
     * This method will preserve the order in which entries are stored in the
     * given class path.
     * If an entry was already in the class path, this method will not add it
     * again. This is consistent with the way the JVM searches the class path, 
     * as a class path of {@code x:y:x} is equivalent to {@code x:y}.
     * @param cp the entries to add.
     * @return itself to facilitate fluent API style.
     * @throws NullPointerException if the argument is {@code null}.
     * @see #toStream()
     * @see #toString()
     */
    public ClassPath add(ClassPath cp) {
<span class="fc" id="L95">        requireNonNull(cp, &quot;cp&quot;);</span>
<span class="fc" id="L96">        entries.addAll(cp.entries);</span>
<span class="fc" id="L97">        return this;</span>
    }
    
    /**
     * @return the entries in this class path, in the same order in which they
     * were {@link #add(Path...) added}.
     */
    public Stream&lt;Path&gt; toStream() {
<span class="fc" id="L105">        return entries.stream();</span>
    }
    
    /**
     * Turns this class path into its JVM string representation where path 
     * entries are separated by a {@link ClassPath#Separator}. 
     * Entries will be output in the same order in which they were {@link 
     * #add(Path...) added}.
     * If this class path only has one entry, that path is returned as a string 
     * without any added {@link #Separator separator}. If this class path is 
     * {@link #isEmpty() empty}, then the empty string is returned.
     */
    @Override
    public String toString() {
<span class="fc" id="L119">        return toStream().map(Path::toString).collect(joining(Separator));</span>
    }
    
    @Override
    public int hashCode() {
<span class="nc" id="L124">        return toString().hashCode();</span>
    }
    
    @Override
    public boolean equals(Object other) {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (this == other) {</span>
<span class="nc" id="L130">            return true;</span>
        }
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (other instanceof ClassPath) {</span>
<span class="fc" id="L133">            return toString().equals(other.toString());</span>
        }
<span class="nc" id="L135">        return false;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>Smuggler All Tests (Mar 29, 2016 9:20:39 AM)</div></body></html>