<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ObjectParser.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Smuggler All Tests (Mar 29, 2016 9:20:39 AM)</a> &gt; <a href="../../index.html" class="el_group">ome-smuggler</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">util.validation</a> &gt; <span class="el_source">ObjectParser.java</span></div><h1>ObjectParser.java</h1><pre class="source lang-java linenums">package util.validation;

import static java.util.Objects.requireNonNull;

import java.util.stream.Stream;

import util.object.Either;

/**
 * Turns a textual representation of a {@code T}-value into an instance of 
 * {@code T}.
 */
public interface ObjectParser&lt;T&gt; {
        
    /**
     * Same as {@link #parse(Stream)} but doesn't check if the argument is
     * {@code null}. This is the only method you need to implement as you can
     * rely on the default implementation of {@link #parse(Stream)} to do the
     * check. 
     */
    Either&lt;String, T&gt; parseNonNull(Stream&lt;String&gt; tokens);
    
    /**
     * Parses a textual representation of a {@code T}-value. 
     * @param value the input to parse, may be {@code null} or empty.
     * @return either the parsed value (right) or a parse error message (left).
     * @param tokens the tokens that make up the state of a {@code T}-value,
     * typically {@code T}'s fields. Tokens are allowed to be {@code null} or 
     * empty.
     * @return either the parsed value (right) or a parse error message (left).
     * @throws NullPointerException if the argument is {@code null}.
     */
    default Either&lt;String, T&gt; parse(Stream&lt;String&gt; tokens) {
<span class="fc" id="L34">        requireNonNull(tokens, &quot;tokens&quot;);</span>
<span class="fc" id="L35">        return parseNonNull(tokens);</span>
    }
    
    /**
     * Convenience method, same as {@link #parse(Stream)}.
     */
    default Either&lt;String, T&gt; parse(String...tokens) {
<span class="fc" id="L42">        requireNonNull(tokens, &quot;tokens&quot;);</span>
<span class="fc" id="L43">        return parseNonNull(Stream.of(tokens));</span>
    }
    
    /**
     * Combines this parser with a validator.
     * First applies this parser to turn tokens into a {@code T}-value,
     * then the given validator decides if the parsed value is legit. 
     * If this parser fails, then the process stops there and the parse error
     * is returned; otherwise the parsed value is given to the validator.
     * If validation fails, then the validation error is returned; otherwise
     * the parsed value is returned.
     * @param validator the validation to apply to the parsed value.
     * @return a parser that uses this object to do the parsing and then applies
     * the given validator to the parsed result.
     * @throws NullPointerException if the argument is {@code null}.
     */
    default ObjectParser&lt;T&gt; withValidation(Validator&lt;String, T&gt; validator) {
<span class="fc" id="L60">        requireNonNull(validator);</span>
<span class="fc" id="L61">        return tokens -&gt; parse(tokens).bind(validator::validate);</span>
    }
    
}
/* NOTE. A poor man's interface for parsing.
 * Moderately useful for validation, but seriously hampered by the lack of 
 * composability. Use it if it fits your needs but be aware that there are 
 * way better options out there, most notably parser combinator libraries.
 *
 * To see why this approach to parsing is lame think of how you could combine
 * two parsers into a third, e.g. an integer parser with one that checks if
 * the integer is positive. Well, I needed to make a special case for that 
 * (withValidation method) even though, in principle, it's not really a very
 * a different concept: 
 * 
 *  + parsing = transforming some input into a result value or an error
 *  + validation = transforming an input into itself or an error
 *  
 * Surely these guys must be siblings? (In fact they belong to the same family
 * of functions; you can come up with a polymorphic function to represent the
 * whole family.)  
 * I'm kicking myself. Nuff said. 
 */
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>Smuggler All Tests (Mar 29, 2016 9:20:39 AM)</div></body></html>