<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>MessageRepeater.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Smuggler All Tests (Mar 29, 2016 9:20:39 AM)</a> &gt; <a href="../../index.html" class="el_group">ome-smuggler</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">ome.smuggler.core.msg</a> &gt; <span class="el_source">MessageRepeater.java</span></div><h1>MessageRepeater.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">package ome.smuggler.core.msg;</span>

import static java.util.Objects.requireNonNull;
import static ome.smuggler.core.msg.RepeatAction.Repeat;
import static util.sequence.Arrayz.hasNulls;

import java.time.Duration;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.stream.Stream;

import ome.smuggler.core.types.FutureTimepoint;
import ome.smuggler.core.types.Schedule;

/**
 * Plugs into a {@link ReschedulingSink} to deliver the same message to sink's
 * consumers multiple times at predefined intervals for a finite number of 
 * times.
 * &lt;p&gt;A repeater is configured with a consumer and a sequence of {@code n &gt; 0} 
 * {@link Duration}s {@code d[0], .., d[n-1]}. When the first message {@code m}
 * comes in at time {@code t0}, it is delivered to the consumer. If the consumer
 * returns {@link RepeatAction#Stop Stop} no further action is taken; if it
 * returns {@link RepeatAction#Repeat Repeat} instead, then {@code m} will be
 * delivered again to the consumer at time {@code t1 = t0 + d[0]}. When given 
 * the message again at time {@code t1}, the consumer can either {@link 
 * RepeatAction#Stop Stop} or {@link RepeatAction#Repeat Repeat}, in which case
 * {@code m} will be delivered again to the consumer at time {@code t2 = t1 + 
 * d[1]}. And so on for at most {@code n} deliveries, past which point {@code m}
 * is given to a configured exceeded re-delivery handler.
 * &lt;/p&gt;
 * &lt;p&gt;A typical use case for a repeater is that of retrying failed actions. 
 * The consumer would carry out some task using the message as input. If a
 * transient error occurs, the consumer would ask to {@link RepeatAction#Repeat 
 * repeat} the delivery later; if the error is permanent the consumer would just
 * {@link RepeatAction#Stop stop} instead. The consumer can retry up to {@code 
 * n} times; past that, the message is fed into the exceeded re-delivery handler
 * which would be some kind of permanent failure handler in this scenario.    
 * &lt;/p&gt;
 */
public class MessageRepeater&lt;T&gt; implements Reschedulable&lt;T&gt; {

    private static Duration[] collectIntervals(Stream&lt;Duration&gt; xs) {
<span class="fc" id="L43">        Duration[] intervals = xs.toArray(Duration[]::new);</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">        if (hasNulls(intervals)) {</span>
<span class="fc" id="L45">            throw new IllegalArgumentException(&quot;repeat intervals has nulls&quot;);</span>
        }
<span class="fc" id="L47">        return intervals;</span>
    }
    
    private final RepeatConsumer&lt;T&gt; consumer;
    private final Duration[] repeatIntervals;
    private final Reschedulable&lt;T&gt; lastDeliveryHandler;

    /**
     * Creates a new instance.
     * @param consumer consumes the message output from the channel and returns
     * an indication of whether the same message should be delivered again. 
     * @param repeatIntervals intervals at which to re-deliver the message. 
     * @param exceededRedeliveryHandler is given the message after {@code n} 
     * re-deliveries, where {@code n} is the number of repeat intervals.
     * @throws NullPointerException if any argument is {@code null}.
     * @throws IllegalArgumentException if the retry intervals stream is empty
     * or contains {@code null}.
     */
<span class="fc" id="L65">    public MessageRepeater(RepeatConsumer&lt;T&gt; consumer,</span>
                           Stream&lt;Duration&gt; repeatIntervals,
                           Consumer&lt;T&gt; exceededRedeliveryHandler) {
<span class="fc" id="L68">        requireNonNull(consumer, &quot;consumer&quot;);</span>
<span class="fc" id="L69">        requireNonNull(repeatIntervals, &quot;repeatIntervals&quot;);</span>
<span class="fc" id="L70">        requireNonNull(exceededRedeliveryHandler, &quot;exceededRedeliveryHandler&quot;);</span>
        
<span class="fc" id="L72">        this.consumer = consumer;</span>
<span class="fc" id="L73">        this.repeatIntervals = collectIntervals(repeatIntervals);</span>
<span class="fc" id="L74">        this.lastDeliveryHandler = ReschedulableFactory.buildOnceOffSchedule(</span>
<span class="fc" id="L75">                                        consumer, exceededRedeliveryHandler);</span>
<span class="fc" id="L76">    }</span>
    
    private Optional&lt;Integer&gt; deliver(CountedSchedule current, T data) {
<span class="fc" id="L79">        int retryCount = current.count().get().intValue() - 1;  // PositiveN is always &gt; 0</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (retryCount &lt; repeatIntervals.length) {</span>
<span class="fc" id="L81">            RepeatAction outcome = consumer.consume(data);</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">            return outcome == Repeat ? Optional.of(retryCount) : </span>
<span class="fc" id="L83">                                       Optional.empty();</span>
        } else {
<span class="fc" id="L85">            lastDeliveryHandler.consume(current, data);</span>
<span class="fc" id="L86">            return Optional.empty();</span>
        }
    }
    
    private FutureTimepoint nextRetryTime(int retryCount) {
<span class="fc" id="L91">        return new FutureTimepoint(repeatIntervals[retryCount]);</span>
    }
    
    @Override
    public Optional&lt;Schedule&lt;T&gt;&gt; consume(CountedSchedule current, T data) {
<span class="fc" id="L96">        return deliver(current, data)</span>
<span class="fc" id="L97">              .map(this::nextRetryTime)</span>
<span class="fc" id="L98">              .map(when -&gt; new Schedule&lt;&gt;(when, data));</span>
    }

}
/* NOTE. Why do this when HornetQ supports delayed re-delivery?!
 * Before you send WTH's flying all over, know that at least I tried it, 
 * but there was some dodginess I couldn't quite figure out, eventually
 * ran out of debug cycles I could use on this, so decided to implement
 * re-delivery myself.
 * 
 * For the record, this is what I initially attempted:
 * 
 * 1. Change ServerConnector to create a transacted session.
 * 2. EnqueueTask commits the session after sending the message.
 * 3. DequeueTask rolls back if an the consumer says so.
 * 
 * The code was basically lifted from the HornetQ &quot;delayed re-delivery&quot; and
 * and &quot;transactional&quot; examples. It all seemed to work fine, except for the
 * fact that rolling back was taking ages (i.e. calling the session's rollback
 * method within onMessage) and HornetQ kept on telling me there was something
 * wrong:
 * 
 * + HQ212002: Timed out waiting for handler to complete processing
 * 
 * Okay, now it's my turn for the WTH...
 * 
 * Another thing I didn't have time to test is what messages are rolled back.
 * What happens if producers and consumers share the *same* session---i.e. our
 * set up? Say messages m1 and m2 are on the queue, m1 is delivered to a 
 * consumer which rolls back while m2 still sits on the queue. What is the fate
 * of m2?
 */
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>Smuggler All Tests (Mar 29, 2016 9:20:39 AM)</div></body></html>